// Generated by CoffeeScript 1.6.3
(function() {
  var Bot, EventEmitter, Instr, LightbotGame, Prog, Square,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Square = require('./square');

  Bot = require('./bot');

  Instr = require('./instruction');

  Prog = require('./program');

  EventEmitter = require('events').EventEmitter;

  module.exports = LightbotGame = (function(_super) {
    __extends(LightbotGame, _super);

    function LightbotGame(board, bot, prog) {
      var _this = this;
      this.board = board;
      this.bot = bot;
      this.prog = prog;
      this.ended = false;
      this.looped = false;
      this.goals = [];
      this.seen = {};
      this.eachSquare(function(sq) {
        if (sq.goal) {
          return _this.goals.push(sq);
        }
      });
    }

    LightbotGame.load = function(data) {
      var board, bot, i, instrs, proc, prog, row, square, _i, _j, _len, _len1, _ref;
      board = data.board;
      for (_i = 0, _len = board.length; _i < _len; _i++) {
        row = board[_i];
        for (i = _j = 0, _len1 = row.length; _j < _len1; i = ++_j) {
          square = row[i];
          row[i] = new Square(square);
        }
      }
      bot = new Bot(data.bot.x, data.bot.y, data.bot.dir, data.bot.color);
      _ref = data.prog;
      for (proc in _ref) {
        instrs = _ref[proc];
        data.prog[proc] = instrs.map(function(instr) {
          return new Instr(instr.action, instr.color);
        });
      }
      prog = new Prog(data.prog);
      return new LightbotGame(board, bot, prog);
    };

    LightbotGame.prototype.eachSquare = function(fn) {
      var row, square, _i, _j, _len, _len1, _ref;
      _ref = this.board;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          square = row[_j];
          fn(square);
        }
      }
      return null;
    };

    LightbotGame.prototype.won = function() {
      return this.goals.filter(function(g) {
        return g.tagged;
      }).length === this.goals.length;
    };

    LightbotGame.prototype.lost = function() {
      return this.ended || this.looped;
    };

    LightbotGame.prototype.over = function() {
      return this.won() || this.lost();
    };

    LightbotGame.prototype.tick = function() {
      var instr, state;
      if (this.over()) {
        return null;
      }
      instr = this.prog.next();
      if (instr == null) {
        this.ended = true;
        this.emit('gameOver', 'ended');
        return null;
      }
      this.execute(instr);
      state = this.state();
      if (this.seen[state]) {
        this.looped = true;
        this.emit('gameOver', 'looped');
      }
      this.seen[state] = true;
      if (this.won()) {
        this.emit('gameOver', 'won');
      }
      return instr;
    };

    LightbotGame.prototype.state = function() {
      var board_state;
      board_state = this.goals.map(function(g) {
        if (g.tagged) {
          return 'y';
        } else {
          return 'n';
        }
      }).join('');
      return board_state + '/' + this.prog.state() + '/' + this.bot.state();
    };

    LightbotGame.prototype.draw = function() {
      var chars, row, y, _i, _len, _ref, _results,
        _this = this;
      console.log('----------');
      _ref = this.board;
      _results = [];
      for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
        row = _ref[y];
        chars = row.map(function(square, x) {
          var attrs, char;
          attrs = [];
          char = x === _this.bot.x && y === _this.bot.y ? (_this.bot.color === 'red' ? attrs.push(31) : void 0, _this.bot.color === 'green' ? attrs.push(32) : void 0, ['^', '>', 'v', '<'][_this.bot.dir]) : square.elev;
          if (square.color === 'red') {
            attrs.push(41);
          }
          if (square.color === 'green') {
            attrs.push(42);
          }
          if (square.goal) {
            attrs.push(1);
          }
          if (square.tagged) {
            attrs.push(4);
          }
          if (square.lift) {
            attrs.push(7);
          }
          if (attrs.length) {
            char = "[" + (attrs.join(';')) + "m" + char + "[0m";
          }
          return char;
        });
        _results.push(console.log(chars.join('')));
      }
      return _results;
    };

    LightbotGame.prototype.execute = function(instr) {
      var diff, next, square, x, y, _ref, _ref1, _ref2;
      if (!(instr.color && (instr.color !== this.bot.color))) {
        square = this.board[this.bot.y][this.bot.x];
        switch (instr.action) {
          case 'p1':
          case 'p2':
            this.prog.callProc(instr.action);
            return;
          case 'forward':
          case 'jump':
            _ref = (function() {
              switch (this.bot.dir) {
                case 0:
                  return [this.bot.y - 1, this.bot.x];
                case 1:
                  return [this.bot.y, this.bot.x + 1];
                case 2:
                  return [this.bot.y + 1, this.bot.x];
                case 3:
                  return [this.bot.y, this.bot.x - 1];
              }
            }).call(this), y = _ref[0], x = _ref[1];
            next = (_ref1 = this.board[y]) != null ? _ref1[x] : void 0;
            if (next) {
              if (instr.action === 'forward') {
                if (next.elev === square.elev) {
                  this.bot.moveTo(x, y);
                }
                this.emit('moveBot', x, y);
              } else {
                diff = next.elev - square.elev;
                if (diff === 1 || diff < 0) {
                  this.bot.moveTo(x, y);
                  this.emit('moveBot', x, y);
                }
              }
            }
            break;
          case 'bulb':
            square = this.board[this.bot.y][this.bot.x];
            if (square.goal) {
              square.tagged = !square.tagged;
              this.emit('toggleGoal', this.bot.x, this.bot.y, square.tagged);
            } else if (square.color) {
              this.bot.color = this.bot.color === square.color ? null : square.color;
              this.emit('botChangeColor', this.bot.color);
            } else if (square.lift) {
              square.elev = (function() {
                switch (square.elev) {
                  case 0:
                    return 2;
                  case 2:
                    return 4;
                  case 4:
                    return 0;
                  default:
                    throw "invalid lift elevation: " + square.elev;
                }
              })();
              this.emit('liftMove', this.bot.x, this.bot.y, square.elev);
            } else if (square.warp) {
              (_ref2 = this.bot).moveTo.apply(_ref2, square.warp);
              this.emit.apply(this, ['moveBot'].concat(__slice.call(square.warp)));
            }
            break;
          case 'right':
            this.bot.turnRight();
            this.emit('turnBot', this.bot.dir);
            break;
          case 'left':
            this.bot.turnLeft();
            this.emit('turnBot', this.bot.dir);
            break;
          case 'return':
            this.prog.returnFromProc();
        }
      }
      return this.prog.increment();
    };

    return LightbotGame;

  })(EventEmitter);

}).call(this);
