// Generated by CoffeeScript 1.6.3
(function() {
  var animate, animateTick, animating, animations, arrow, beige, body, body_height, body_radius, bodyg, bot, botX, botY, botZ, bulbBot, camera, canvas, clr, colorBot, cur_level, def, defaults, flat_blue, flat_gray, floor, game, gameOver, gray, group, head, head_radius, headg, i, k, light, lvl, lvl_sel, moveBotTo, moveLiftTo, opt, pref, prev_coords, prop, renderer, rgb, rgbObj, row, scene, speed, square, step, stp, toggleGoal, tops, tri, turnBotTo, txt, updateScene, wireframe, x, y, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;

  rgb = function(clr) {
    return {
      green: 0x00ff00,
      red: 0xff0000,
      teal: 0x00bbbb,
      yellow: 0xffff00,
      gray: 0xcccccc,
      beige: 0xf5f5dc
    }[clr];
  };

  rgbObj = function(clr) {
    var hex;
    hex = rgb(clr);
    return {
      r: (hex >> 16) / 255,
      g: ((hex & 0xff00) >> 8) / 255,
      b: (hex & 0xff) / 255
    };
  };

  speed = 1;

  canvas = document.createElement('canvas');

  renderer = window.WebGLRenderingContext && canvas.getContext('webgl') && canvas.getContext('experimental-webgl') ? new THREE.WebGLRenderer({
    antialias: true
  }) : new THREE.CanvasRenderer({
    antialias: true
  });

  renderer.setSize(window.innerWidth - 5, window.innerHeight - 5);

  document.body.appendChild(renderer.domElement);

  window.camera = camera = new THREE.OrthographicCamera(-1e7, 1e7, 1e7, -1e7, -1e8, 1e7);

  scene = new THREE.Scene;

  window.updateScene = updateScene = function() {
    return renderer.render(scene, camera);
  };

  window.group = group = new THREE.Object3D;

  group.name = 'group';

  window.light = light = new THREE.PointLight(0xffffff, 1.0, 0);

  light.position.set(500, -500, 1000);

  group.add(light);

  flat_gray = new THREE.MeshLambertMaterial({
    color: rgb('gray'),
    shading: THREE.FlatShading
  });

  beige = new THREE.MeshLambertMaterial({
    color: rgb('beige'),
    shading: THREE.FlatShading
  });

  gray = new THREE.MeshLambertMaterial({
    color: rgb('gray')
  });

  flat_blue = new THREE.MeshLambertMaterial({
    color: 0x0000ff,
    shading: THREE.FlatShading
  });

  wireframe = new THREE.MeshBasicMaterial({
    wireframe: true,
    wireframeLinewidth: 2,
    color: 0x666666
  });

  floor = new THREE.Mesh(new THREE.PlaneGeometry(100000, 100000), new THREE.MeshBasicMaterial({
    color: 0x333333
  }));

  group.add(floor);

  window.bot = bot = new THREE.Object3D;

  bot.name = 'bot';

  head_radius = 40;

  body_radius = 40;

  body_height = 150;

  headg = new THREE.SphereGeometry(head_radius, 40);

  head = new THREE.Mesh(headg, new THREE.MeshLambertMaterial({
    color: rgb('gray')
  }));

  head.name = 'head';

  head.position.y = body_height / 2 + head_radius;

  bot.add(head);

  bodyg = new THREE.CylinderGeometry(body_radius, body_radius, body_height, 20);

  body = new THREE.Mesh(bodyg, gray);

  body.name = 'body';

  bot.add(body);

  tri = new THREE.Shape;

  tri.moveTo(-50, -90);

  tri.lineTo(0, 90);

  tri.lineTo(50, -90);

  tri.lineTo(-50, -90);

  arrow = new THREE.Mesh(tri.extrude({
    amount: 20
  }), flat_blue);

  arrow.name = 'arrow';

  arrow.rotation.x = Math.PI / 2;

  arrow.rotation.z = Math.PI;

  bot.add(arrow);

  bot.rotation.x = Math.PI / 2;

  group.add(bot);

  tops = [];

  step = function(x, y, height, color, lift) {
    var geom, grp, mat, plane, pole, top;
    if (height == null) {
      height = 2;
    }
    if (color == null) {
      color = null;
    }
    if (lift == null) {
      lift = false;
    }
    grp = new THREE.Object3D;
    grp.name = 'step';
    geom = new THREE.CubeGeometry(200, 200, height);
    grp.add(THREE.SceneUtils.createMultiMaterialObject(geom, [(lift ? beige : flat_gray), wireframe]));
    if (lift) {
      pole = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 400, 10), beige);
      pole.rotation.x = Math.PI / 2;
      pole.position.z = -201;
      grp.add(pole);
      if (tops[y] == null) {
        tops[y] = [];
      }
      tops[y][x] = grp;
    }
    if (color) {
      top = new THREE.Object3D;
      top.position.z = height / 2 + 1;
      geom = new THREE.PlaneGeometry(200, 200);
      mat = new THREE.MeshBasicMaterial({
        color: rgb(color)
      });
      plane = new THREE.Mesh(geom, mat);
      if (tops[y] == null) {
        tops[y] = [];
      }
      tops[y][x] = plane;
      top.add(plane);
      grp.add(top);
    }
    grp.position.x = x * 200;
    grp.position.y = -y * 200;
    return grp;
  };

  cur_level = (_ref = localStorage.getItem('level')) != null ? _ref : ((function() {
    var _results;
    _results = [];
    for (k in levels) {
      _results.push(k);
    }
    return _results;
  })())[0];

  game = Lightbot.Game.load(levels[cur_level]);

  animating = 0;

  animateTick = function() {
    if (!animating) {
      return;
    }
    requestAnimationFrame(animateTick);
    return TWEEN.update();
  };

  animations = [];

  animate = function(obj, ms, to, parallel) {
    var last, tween;
    if (parallel == null) {
      parallel = false;
    }
    animating++;
    tween = new TWEEN.Tween(obj).to(to, ms).easing(TWEEN.Easing.Quadratic.InOut).interpolation(TWEEN.Interpolation.Bezier).onUpdate(updateScene).onComplete(function() {
      return animating--;
    });
    if (parallel) {
      last = animations[animations.length - 1];
      if (last instanceof Array) {
        last.push(tween);
      } else {
        animations.pop();
        animations.push([last, tween]);
      }
    } else {
      animations.push(tween);
    }
    return tween;
  };

  botX = function(x) {
    return x * 200;
  };

  botY = function(y) {
    return y * -200;
  };

  botZ = function(elev) {
    return body_height / 2 + 1 + elev * 100;
  };

  moveBotTo = function(x, y, jump) {
    var coords, elev, to_z, tween;
    if (jump == null) {
      jump = true;
    }
    elev = game.board[y][x].elev;
    to_z = botZ(elev);
    coords = {
      x: botX(x),
      y: botY(y),
      z: [to_z]
    };
    tween = animate(bot.position, 1000 / speed, coords);
    tween.onStart(function() {
      var from_z, _ref1;
      from_z = bot.position.z;
      if (to_z !== from_z && jump) {
        return ([].splice.apply(coords.z, [1, 0].concat(_ref1 = Math.max(to_z, from_z) + 100)), _ref1);
      }
    });
    return tween;
  };

  turnBotTo = function(dir) {
    var to;
    to = {
      y: (4 - dir) * Math.PI / 2
    };
    return animate(bot.rotation, 1000 / speed, to).onStart(function() {
      var cur, rot, _ref1;
      cur = (4 - (Math.round(bot.rotation.y / Math.PI * 2) % 4)) % 4;
      if (Math.abs(dir - cur) % 2) {
        rot = 1;
        if ((_ref1 = cur - dir) === (-1) || _ref1 === 3) {
          rot = -1;
        }
        return to.y = bot.rotation.y + rot * Math.PI / 2;
      }
    });
  };

  moveLiftTo = function(x, y, elev) {
    var lift;
    lift = tops[y][x];
    moveBotTo(x, y, false);
    return animate(lift.position, 1000 / speed, {
      z: 1 + 100 * elev
    }, true);
  };

  bulbBot = function() {
    animate(head.material.color, 250 / speed, rgbObj('yellow'));
    return animate(head.material.color, 250 / speed, rgbObj('gray'));
  };

  colorBot = function(color) {
    return animate(body.material.color, 0, rgbObj(color != null ? color : 'gray'));
  };

  toggleGoal = function(x, y, tagged) {
    return animate(tops[y][x].material.color, 0, rgbObj(tagged ? 'yellow' : 'teal'));
  };

  gameOver = function(reason) {
    return animate({}, 0, {}).onStart(function() {
      return document.getElementById('status').firstChild.nodeValue = "You " + reason;
    });
  };

  _ref1 = game.board;
  for (y = _i = 0, _len = _ref1.length; _i < _len; y = ++_i) {
    row = _ref1[y];
    for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
      square = row[x];
      clr = square.goal ? 'teal' : square.color;
      if (square.lift) {
        stp = step(x, y, null, clr, true);
        stp.position.z = 1 + 100 * square.elev;
        group.add(stp);
      } else {
        if (square.elev === 0) {
          stp = step(x, y, null, clr);
          stp.position.z = 1;
          group.add(stp);
        } else {
          for (i = _k = 0, _ref2 = square.elev; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
            stp = step(x, y, 100, (i === (square.elev - 1) ? clr : null));
            stp.position.z = 50 + 100 * i;
            group.add(stp);
          }
        }
      }
    }
  }

  defaults = {
    position: [-2e6, 2e6, 0],
    rotation: [-7.25, 0, -0.5],
    scale: [8200, 8200, 8200]
  };

  for (prop in defaults) {
    def = defaults[prop];
    pref = localStorage.getItem(prop);
    group[prop].fromArray(pref ? JSON.parse(pref) : def);
  }

  scene.add(group);

  bot.position.x = botX(game.bot.x);

  bot.position.y = botY(game.bot.y);

  bot.position.z = botZ(game.board[game.bot.y][game.bot.x].elev);

  bot.rotation.y = (4 - game.bot.dir) * Math.PI / 2;

  updateScene();

  prev_coords = [null, null];

  document.body.addEventListener('mousedown', function(e) {
    var _ref3;
    if ((_ref3 = e.target) !== document.body && _ref3 !== renderer.domElement) {
      return;
    }
    prev_coords[e.button] = [e.clientX, e.clientY];
    renderer.domElement.style.cursor = 'move';
    return e.preventDefault();
  });

  document.body.addEventListener('mouseup', function(e) {
    var attr, _l, _len2, _ref3, _ref4, _results;
    if ((_ref3 = e.target) !== document.body && _ref3 !== renderer.domElement) {
      return;
    }
    prev_coords[e.button] = null;
    renderer.domElement.style.cursor = 'default';
    _ref4 = ['rotation', 'position', 'scale'];
    _results = [];
    for (_l = 0, _len2 = _ref4.length; _l < _len2; _l++) {
      attr = _ref4[_l];
      _results.push(localStorage.setItem(attr, JSON.stringify(group[attr].toArray())));
    }
    return _results;
  });

  document.body.addEventListener('mousemove', function(e) {
    var but, dx, dy, prev, _l, _len2, _results;
    _results = [];
    for (but = _l = 0, _len2 = prev_coords.length; _l < _len2; but = ++_l) {
      prev = prev_coords[but];
      if (!prev) {
        continue;
      }
      dx = e.clientX - prev[0];
      dy = e.clientY - prev[1];
      if (but === 0) {
        group.rotation.x += dy / 100;
        group.rotation.z += dx / 100;
      } else if (but === 1) {
        group.position.x += dx * 5000;
        group.position.y -= dy * 10000;
      }
      prev_coords[but] = [e.clientX, e.clientY];
      _results.push(updateScene());
    }
    return _results;
  });

  document.getElementById('reset').addEventListener('click', function(e) {
    for (prop in defaults) {
      def = defaults[prop];
      group[prop].fromArray(def);
      localStorage.removeItem(prop);
    }
    updateScene();
    return false;
  });

  document.getElementById('stop').addEventListener('click', function(e) {
    animating = 0;
    return false;
  });

  lvl_sel = document.getElementById('level');

  for (lvl in levels) {
    opt = document.createElement('option');
    txt = document.createTextNode(lvl);
    opt.appendChild(txt);
    if (lvl === cur_level) {
      opt.selected = true;
    }
    lvl_sel.appendChild(opt);
  }

  lvl_sel.addEventListener('change', function(e) {
    localStorage.setItem('level', e.target.selectedOptions[0].firstChild.nodeValue);
    return window.location.reload();
  });

  window.addEventListener('mousewheel', function(e) {
    var factor;
    factor = e.wheelDelta / 100;
    if (factor < 0) {
      factor = Math.abs(1 / factor);
    }
    group.scale.multiplyScalar(factor);
    updateScene();
    return e.preventDefault();
  });

  game.on('bulbBot', bulbBot);

  game.on('botChangeColor', colorBot);

  game.on('moveBot', moveBotTo);

  game.on('turnBot', turnBotTo);

  game.on('liftMove', moveLiftTo);

  game.on('toggleGoal', toggleGoal);

  game.on('gameOver', gameOver);

  while (!game.over()) {
    game.tick();
  }

  setTimeout((function() {
    var cur, first, tween, _l, _len2;
    cur = first = animations.shift();
    for (_l = 0, _len2 = animations.length; _l < _len2; _l++) {
      tween = animations[_l];
      if (tween instanceof Array) {
        cur.chain.apply(cur, tween);
        cur = tween[0];
      } else {
        cur.chain(tween);
        cur = tween;
      }
    }
    first.start();
    return animateTick();
  }), 500);

}).call(this);

/*
//@ sourceMappingURL=demo.map
*/
